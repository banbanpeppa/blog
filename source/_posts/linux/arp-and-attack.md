---
layout:     post
title:      ARP的原理与基本流程
date:       2019-08-06 19:18:00
author:     "banban"
header-img: "/images/linux/arp-bg.png"
catalog: true
tags:
    - Linux
---

# ARP的原理与基本流程

在局域网环境下，主机之间是通过ARP协议获取对应机器的MAC地址的，ARP交换是在二层网络上面的协议。IP数据包在以太网中传递，但是对于以太网设备是不能识别32位的IP地址的，它只能识别48的物理MAC地址，为此在每一台主机上面都会维护一张从IP地址到物理地址的映射表，而不断更新这个映射表就是ARP（地址解析协议）所需要做的事情，ARP协议位于TCP-IP协议的底层。

ARP协议的主要流程是

- 1\. 当网络层的TCP-IP协议封装的数据包传来时，主机A解开对应的数据包，得到对应的主机B的目的IP地址
- 2\. 根据封包中的目的IP地址去检索本地的ARP表，分三种情况处理
    - 如果找到了对应的记录则将对应的目的MAC地址装入到帧数据包，同时将数据包发送至对应的主机；
    - 如果在本地的ARP表中没有对应的映射记录，主机A需要确定对应的目的IP地址和自己是否在同一个子网下，如果在同一个子网下面，则主机A会发起一个ARP Reply的广播封包请求，这个封包会发送至局域网中的每一台机器；进入3
    - 如果不在同一个子网下，则主机A会将ARP Reply封包发给默认网关询问对应的MAC地址
- 3\. 当机器接收到了ARP Reply封包之后，解开封包查看目的IP地址是否为自己的IP地址，如果是则将源MAC地址和IP地址记录在本地的ARP表中（如果已经存在则覆盖），同时回应自己的MAC地址和IP地址响应主机A；如果解开之后的目的IP地址不是自己的地址，则忽略
- 4\. 在发送端收到了对应的ARP响应之后，则将ARP Reply的记录添加到本地的ARP表中，同时用这个目的地址将数据发送至目的主机

举一个例子，如下图
![image](/images/linux/arp.jpg)

- 主机A想要访问公网，执行了`ping 114.114.114.114`的操作
- A默认会将这个请求包也就是ping包发给网关192.168.10.1，但是主机A并不知道网关的mac地址，于是这个时候A会发送一个ARP Request的广播请求，询问在局域网中IP地址为192.168.10.1的mac地址。
- 当路由器收到了这个ARP请求之后，发现请求中的ip地址是自己的地址，会回应A，发送一个回应单播包给A，告诉它自己的mac地址是什么。
- 当A拿到了网关的物理地址后，就可以将icmp的数据包封装并发送到对应的路由器中
- 路由器解开数据包判断对应的目的地址是什么，然后查看自己本地的路由表进行路由，将请求包转发出去。
- 路由器在之后接受到了公网回应的icmp回显包的时候，会看到这个回显包的源地址是`114.114.114.114`，目的地址是`192.168.10.3`，因为路由器需要查看自己本地的arp表去查看是否有对应的目的地址的匹配表，如果有则将回显包发送到对应的mac地址的机器A，如果没有，就需要在局域网中发送一个arp request的请求，询问A的mac地址。
- 主机A最后收到了icmp的回显包
  
在这个过程中，会看到假设说主机A或者路由器在自己本地的arp表中如果没有对应的记录的时候，都需要去询问对应的mac地址并且更新arp表，也就是说arp表示会一致刷新的。

那么在linux系统中，我们的arp表到了什么情况会被清理呢？

在linux系统中，arp表是缓存在内存中的，因此在到了一定的量之后，会有对应的垃圾回收器来回收对应的arp表。对应的配置在一下文件中可以找到
```
Debian 9

/proc/sys/net/ipv4/neigh/default/gc_thresh1 
/proc/sys/net/ipv4/neigh/default/gc_thresh2 
/proc/sys/net/ipv4/neigh/default/gc_thresh3
```
默认来说他们的值分别为128、512、1024，第一个值的垃圾回收器运行的最低要求，也就是说在arp数目达到了这个值之后才会启动对应的垃圾回收进程，第二个值是一个开始回收的阈值，当arp表的数目超过这个值一定时间（5秒）之后，垃圾回收器就会对arp表进行回收，而第三个值则是一个触发阈值，就是说一旦超过这个值垃圾回收器马上就进行arp的清理，当然在垃圾回收的时候，并不是全部都刷掉的，而是会根据一定的策略进行回收。

## ARP欺骗

其实在ARP的整个工作流程中不难看出，其实是存在一定的可乘之机的。也就是说在图中的B主机是可以加入到整个arp工作流程来进行arp欺骗的。

具体的做法如下
![image](/images/linux/arp_cheat.jpg)

- 在A需要往外发送icmp的一个回显请求报文的时候，主机B发起ARP攻击，重复得发送一个ARP回应包，包的内容为`mac:xx:xx:xx:yy:xx ip:192.168.10.1`，以此来伪装自己就是网关，让A将数据发给自己
- 于此同时，主机B也通过回应报文的形式告诉网关也就是路由器，称自己是主机A，具体的报文内容为`max: xx:xx:xx:yy:xx ip: 192.168.10.3`，这样主机B就达到了数据包嗅探的能力
- 主机A先将自己的数据包发给B，因为它误以为B是网关，B再将数据转发给路由器，这个时候路由器接收了数据之后将数据转发到公网
- 这里主机B是完全可以侦听A的数据包的，甚至去篡改A的数据包
  
下面可以通过linux来模拟这么一个实验

首先安装一个arp攻击的模拟工具包
```
apt install dsniff
```
同时在攻击的机器上面打开ip转发
```
echo 1 > /proc/sys/net/ipv4/ip_forward
```

然后使用 arpspoof 命令进行欺骗, 命令使用方法如下:
```
arpspoof -i <网卡名> -t <欺骗的目标> <我是谁>
```

分别开两个终端:

终端1, 欺骗主机 A 我是网关
```
arpspoof -i eth0 -t 192.168.10.3 192.168.10.1
```
终端2, 欺骗网关我是主机 A
```
arpspoof -i eth0 -t 192.168.10.1 192.168.10.3
```

这样之后，在主机B上面就可以执行tcpdump或者urlsnarf来侦听数据了
```
apt install tcpdump snarf
```
使用tcpdump
```
tcpdump -nntvvv -i eth0 port 8080 
```
使用urlsnarf
```
urlsnarf -i eth0
```

arp欺骗的形式有很多，例如有：中间人攻击、被动式数据嗅探。

如何防御 ARP 欺骗攻击?

- 可以通过登陆到网关地址所在的机器中（路由器）中修改配置，将ip和mac地址绑定，绑定之后就不会让arp攻击者肆意更改网关所在的arp表了。网络设备例如交换机有一种叫做动态ARP防御的技术叫做DAI，交换机会维护一张ip-mac-port的表，如果在arp询问过程中出现有冲突的就会丢弃。
- 对于客户机，可以在本地记录mac-ip的对应关系表，当出现欺骗的时候及时发现并且丢弃。这方面可以使用一些软件辅助电脑例如腾讯管家、360。

## 参考

* [局域网 ARP 欺骗原理详解](https://segmentfault.com/a/1190000009562333)
* [浅谈Arp攻击和利用Arp欺骗进行MITM](https://www.anquanke.com/post/id/151762)